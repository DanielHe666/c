# 技术知识点

## 在线 C 语言编译器

- Monaco Editor 集成
  - 项目未使用打包工具，直接通过 CDN 提供的 AMD loader 引入 Monaco：
```js
require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' } });
require(['vs/editor/editor.main'], () => {
  window.editor = monaco.editor.create(document.getElementById('editor'), {
    value: DEFAULT_CODE,
    language: 'c',
    theme: localStorage.getItem('editorTheme') === 'light' ? 'vs-light' : 'vs-dark',
    automaticLayout: true,
    minimap: { enabled: false },
    fontSize: 13
  });
});
```
  - 重点：使用 `automaticLayout` 保障窗口缩放时不需要手动 `layout`；使用 `window.editor.trigger` 绑定撤销/重做、注释切换等命令；通过 CSS 控制整体暗/明主题。
  - 面试补充：相比 `textarea`，Monaco 自带语法折叠、多光标、命令面板，提升在线编译器体验；项目中测试过 Chrome/Safari/Edge 的中文输入法，未出现光标漂移。

- 智能缩进 / 格式化
  - 采用自定义的 `smartCIndent` 函数，对每行代码建立状态机，核心规则：
    1. 维护块栈统计 `{}` 层级；
    2. 为 `case/default`、`do...while` 设置专属分支避免误缩；
    3. 遍历时跳过字符串、注释，保证内部花括号不干扰。
```js
function smartCIndent(code, tabSize = 4) {
  const lines = code.split(/\r?\n/);
  let indent = 0;
  let inBlockComment = false, inString = false, stringChar = '';
  return lines.map((line) => {
    const trimmed = line.trim();
    if (trimmed.startsWith('}')) indent = Math.max(0, indent - 1);
    const formatted = ' '.repeat(tabSize * indent) + trimmed;
    // ...扫描字符更新 indent / 状态...
    if (trimmed.endsWith('{')) indent += 1;
    return formatted;
  }).join('\n');
}
```
  - 面试补充：若老师问为何不用 AST，可以说明 AST 解析器体积大且需要完整 C 标准库；纯栈 + 状态机已经覆盖主流语法结构，成本更低。

- 浏览器持久化策略
  - 使用多个 localStorage Key 分别记录代码、主题、测试用例：
```js
localStorage.setItem('deepseek_saved_c', window.editor.getValue());
localStorage.setItem('editorTheme', isDark ? 'dark' : 'light');
localStorage.setItem('test_cases_v1', JSON.stringify(cases));
```
  - 页面加载时先读取存档，fallback 到默认模板；在 `beforeunload` 事件中追加自动保存，减少意外丢失。
  - 面试补充：Safari 隐私模式会抛出 `QuotaExceededError`，因此所有写操作都包裹 `try...catch` 并在 UI 提醒用户。

- Wandbox API 调用
  - 运行按钮触发 `tryWandboxCompile`，内部实现：
```js
const wandboxUrl = 'https://wandbox.org/api/compile.json';
const resp = await fetch(wandboxUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ code, compiler: 'gcc-head', stdin })
});
const json = await resp.json();
const out = (json.program_output || '') + (json.program_error ? `\n[stderr]\n${json.program_error}` : '');
stdoutEl.textContent = `${out}\n[exit code] ${json.status ?? 0}`;
```
  - 若请求失败（超时 / 网络 / HTTP 错误），直接在输出面板显示真实错误信息并写入控制台，无本地 WASM 回退，用真实情况教育用户。
  - 面试补充：通过 `Promise.race` + 手动超时避免长时间等待；在测试用例批量运行里沿用同一 API，统一错误处理经验。

- URL hash 分享
  - 分享弹窗会把数据打包成 JSON 再 Base64：
```js
function buildShareUrl(opts) {
  const payload = {
    code: window.editor.getValue(),
    stdin: opts.stdin ? stdinEl.value : undefined,
    cases: opts.cases ? cases : undefined,
    name: currentFilename
  };
  const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  return `${location.origin}${location.pathname}#share=${b64}`;
}
```
  - 页面加载检查 `location.hash`，若识别到 `#share=` 前缀就解码恢复编辑器、stdin 和测试用例。
  - 面试补充：Base64 长度比原文短一截，但仍受浏览器 URL 长度限制；所以 UI 中提示“过长建议下载文件”。

- Service Worker / PWA
  - 手写 `sw.js` 维护固定版本号，核心策略是 precache + cache-first：
```js
const CACHE_NAME = `c-compiler-${VERSION}`;
self.addEventListener('fetch', (event) => {
  if (event.request.method !== 'GET') return;
  event.respondWith(
    caches.match(event.request).then((cached) => cached || fetch(event.request).then((resp) => {
      if (resp.status === 200) caches.open(CACHE_NAME).then((cache) => cache.put(event.request, resp.clone()));
      return resp;
    }).catch(() => caches.match(event.request)))
  );
});
```
  - 安装阶段缓存首页、Manifest、图片；激活时清理旧版本缓存，并在离线时返回友好文本提示。
  - 面试补充：没有借助 Workbox，便于完全掌控缓存逻辑；通过 `scripts/version.js` 的版本号手动触发缓存刷新。

- GitHub Pages 发布
  - 项目无构建链路，直接把静态资源放在主分支根目录，GitHub Pages 自动部署。若要更新，只需 `git push` 主分支。
  - 面试补充：若老师问自动化，可说明未来计划增加轻量工作流生成压缩版资源；目前重点是快速迭代前端功能。


## 代码高尔夫平台

- 阿里云 ECS 运维流程
  - 购买 Ubuntu 镜像的轻量应用服务器后，配置安全组开放 80/443 端口，使用 Nginx 做反向代理并开启 gzip。域名通过阿里云解析到公网 IP，同时准备 ICP 备案资料。

```bash
# 安装 Nginx 并启动
sudo apt update && sudo apt install -y nginx
sudo systemctl enable nginx --now

# 简单的反向代理配置，转发到内部 3000 端口
cat <<'EOF' | sudo tee /etc/nginx/sites-available/codegolf
server {
    listen 80;
    server_name zjucodegolf.xyz;
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
EOF
sudo ln -s /etc/nginx/sites-available/codegolf /etc/nginx/sites-enabled/
sudo nginx -s reload
```

说明：部署完成后还需要设置防火墙（如 `ufw allow 'Nginx Full'`）确保端口开放。老师若问到 SSL，可以补充使用 `certbot` 申请证书并定期自动续期。阿里云轻量应用伺服器默认只有一个网卡，若后续要做高可用，要再加上 SLB 或者迁移到 ECS 标准型实例。

- 前后端分离架构设计
  - 前端使用响应式布局，主要页面包括题库列表、题目详情、排行榜。后端提供 RESTful API，比如 `GET /api/problems` 获取题目，`POST /api/submissions` 提交代码。通过 JWT 维持登录态。

```txt
GET  /api/problems            # 返回题目列表
GET  /api/problems/:id        # 返回单题详情
POST /api/submissions         # 提交代码进行评测
GET  /api/leaderboard         # 返回天梯榜数据
```

说明：接口需要结合权限控制，例如只允许管理员调用 `POST /api/problems` 发布新题。老师可能会问如何设计错误码，可以回答：通用的 REST 会返回 `400`（参数错误）、`401`（未登入）、`429`（超出频率限制）等，并在 body 中给出具体原因，方便前端提示用户。

- 数据库建模实践
  - 采用 MySQL，核心表包括 `problems`、`users`、`submissions`、`leaderboard_snapshots`。`submissions` 表记录代码字节数和完成时间，借此生成排行榜。

```sql
CREATE TABLE submissions (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  problem_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  bytes INT NOT NULL,
  status ENUM('AC','WA','CE') NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_problem_user (problem_id, user_id)
);
```

说明：`status` 使用 ENUM 可以保证状态值在允许范围内。老师如果问到如何避免同一题重复提交导致刷榜，可以说会新增唯一索引 `UNIQUE (problem_id, user_id)` 并在代码层做“更优才覆盖”的逻辑，确保排行榜公平。

- 评测系统沙箱
  - 每次评测启动独立 Docker 容器，挂载只读题目数据和一个共享日志目录。容器内禁用网络，并设置 CPU、内存上限，防止滥用。

```bash
docker run --rm \
  --net=none \
  --cpus=1 \
  --memory=256m \
  -v /problems/1001:/workspace:ro \
  -v /logs:/logs \
  codegolf-runner /bin/sh -c "timeout 5s ./run.sh"
```

说明：`timeout 5s` 防止无限循环。如果老师问到“输入如何传递”，可以回答：在容器内将测试数据挂载到 `/workspace/input.txt`，由 `run.sh` 读入。若要支援多语言，需要在镜像里预装多种编译器并根据提交语言选择对应命令。

- AI 辅助提示工作流
  - 提示服务调用大语言模型 API，输入包含用户提交代码、题目文字，输出仅限优化建议（例如可用的位运算技巧）。加入关键字过滤，防止生成完整答案。

```python
from llm import call_llm

prompt = f"""
你是一名代码高尔夫教练。题目描述: {problem_desc}
选手代码:
{user_code}
请给出三个压缩字符数的建议，不要直接给出完整代码。
"""


```

说明：模型返回的内容会先进入审查函数，利用正则或 AST 简析确认没有直接可用的解答，再交给前端显示。老师若追问模型建议是否可信，可以说会在提示旁标注“仅供参考”，同时提供反馈按钮收集使用者对建议的评分，方便调整提示词或更换模型。

- CI/CD 与排行榜联动
  - GitHub Actions 监听 `submissions` 目录的 PR，执行评测脚本并生成 `leaderboard.json`。如果提交字节数更优，则更新榜单并推送到 `gh-pages`。

```yaml
- name: Update leaderboard
  run: |
    python scripts/update_leaderboard.py submissions/
    git config user.name "gh-bot"
    git config user.email "bot@example.com"
    git add leaderboard.json
    git commit -m "Update leaderboard" || echo "No changes"
```

说明：这段脚本确保只有榜单变更时才会有 commit。老师可能会问“多个 PR 同时更新会不会打架”，可以回应：CI 在推送前会 `git pull --rebase`，必要时重新计算榜单；如果仍冲突，会让开发者手动解决或改为将结果写入资料库。

- 安全加固方向
  - 预研使用 gVisor 或 Firecracker 微虚拟化增强隔离。短期内先通过 `seccomp` profile 限制系统调用，只保留编译运行所需的最小指令集。

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64"],
  "syscalls": [
    { "names": ["read", "write", "exit"], "action": "SCMP_ACT_ALLOW" }
  ]
}
```

说明：这只是最小示例，实际需要允许如 `fstat`, `mmap`, `munmap` 等系统调用，否则程式会因缺少基本 IO 能力而崩溃。老师若进一步追问“假如 seccomp 配错导致程式无法运行怎么排查”，可以提到会在容器内查看 `dmesg` 日志，或使用 `strace` 捕捉被拒绝的 syscall，再调整配置。


## AI 医学辅助诊断系统

- RAG 流程拆解
  - 检索阶段使用 Milvus 储存 PubMed 和 CNKI 文献向量，输入症状文本后调用向量检索 API 获取最相似的摘要。生成阶段把检索结果与患者信息一起传给 DeepSeek，要求模型引用证据给出 triage 建议。

```python
# 检索 Milvus
results = milvus.search(collection_name='med_papers', query_embeddings=[embedding], limit=5)

# 调用 DeepSeek
prompt = build_prompt(symptoms, results)
advice = deepseek.generate(prompt)
```

说明：Milvus 检索返回的不仅是文献摘要，还有相似度分数和原始文献 ID。老师如果问“如何避免检索结果过期”，可以说会每天夜间批量刷新向量库，并记录更新时间，生成报表给医学顾问确认。生成阶段会把症状、患者基本信息和文献证据组合成提示词，引导模型必须引用来源。

- 医学数据结构化
  - 症状表单数据通过后端转换成结构化 JSON，包括 `symptom`, `severity`, `onset` 等字段，再输入向量化模型（如 MedBERT）生成嵌入向量。

```json
{
  "case_id": "CASE-001",
  "demographics": {"age_group": "18-25", "gender": "female"},
  "symptoms": [
    {"symptom": "咽喉痛", "severity": "moderate", "onset": "2025-11-10"}
  ]
}
```

说明：这种结构化格式方便后端做校验，例如检查 `severity` 是否在 `mild/moderate/severe` 范围内。老师如果问到多语言输入（中文症状如何转换成英文），可以说会结合自建词典或调用医学术语标准（如 SNOMED CT）将自然语言对应到统一编码。

- 大模型安全策略
  - 提示模板中要求“必须引用检索证据编号”，并在返回后校验。如果模型输出未引用证据或涉及药物剂量等高风险内容，规则引擎会重写为“建议线下就医”。

```python
if not has_reference(advice):
  advice = "当前证据不足，请建议患者尽快线下就医。"
```

说明：这个检查函数会解析模型输出中是否包含像 `[1]` 或 `(PMID:xxxxxx)` 之类的引文标注。老师若问到如何防止模型推荐违规药品，可以说会在规则引擎里增加黑名单词汇，发现敏感词就自动改写成“需要医生评估”。

- 人工校准闭环
  - 审核界面展示模型建议、引用文献、置信度。医生点击“通过/修改/驳回”后，将最终意见写入审核日志表，为后续模型调优提供数据。

```sql
INSERT INTO review_logs(case_id, reviewer, final_decision, confidence)
VALUES (:case_id, :reviewer, :decision, :confidence);
```

说明：人工校准记录可以追踪每条建议的责任人，符合医疗合规要求。老师如果问“人手不够怎么办”，可以说会根据置信度分类，只有低置信度结果才必须人工审核，高置信度结果标注“未经人工复核”让医生快速浏览。

- API 设计范例
  - 前端提交病例数据到 `/api/cases`, 后端返回 triage 信息和建议。接口遵循 REST 风格，返回的 JSON 包含决策解释和证据链。

```http
POST /api/cases
{
  "case_id": "CASE-001",
  "symptoms": [ ... ]
}

HTTP/1.1 200 OK
{
  "triage": "Level 3",
  "recommendation": "建议 24 小时内就诊",
  "references": [ { "id": "PMID:123456" } ]
}
```

说明：接口返回的 `Level 3` 对应院内急诊分级标准，老师可能会问“这个等级从哪里来”，可以回答参考了国际常用的 ESI (Emergency Severity Index)，并请医学顾问调整到本土标准。如果需要图像输入，也可以在 `symptoms` 中增加附件 URL，后端再连接影像识别服务。

- 部署与安全要点
  - 后端部署在阿里云 ECS，预计接入 HTTPS 证书。为演示模式提供“本地存储”选项，把病例数据仅保留在浏览器，降低隐私风险。

```bash
sudo certbot --nginx -d medagt.example.com
```

说明：医疗项目对安全要求高，老师若问还有哪些安全措施，可以补充：部署时会打开阿里云 WAF，并将敏感日志透过 KMS 加密后储存。对于演示账号，会限制只能使用匿名病例，并在登入页加上告警提示。

- 向量数据库维护
  - Milvus 定期导入最新文献摘要，使用定时任务重建索引。对低置信度检索结果进行人工标注并回填，提高后续检索准确率。

```bash
python scripts/update_embeddings.py --source pubmed.csv --collection med_papers
```

说明：这个脚本会重新计算向量并写入 Milvus。老师如果问到“如何确保同步过程不影响线上服务”，可以回答会使用灰度方案：先写入新集合，待检查完毕后再切换索引别名。若源数据格式变动，会先在测试环境演练。

- DeepSeek LLM 集成
  - 通过 HTTP API 发送用户请求，设置温度较低（如 0.2）保证回答稳定可控。预留本地部署接口，以便未来在院内环境运行。

```python
response = requests.post(
  'https://api.deepseek.com/v1/chat/completions',
  headers={'Authorization': f'Bearer {DEEPSEEK_KEY}'},
  json={
    'model': 'deepseek-medical',
    'messages': [
      { 'role': 'system', 'content': '你是医学问诊助手，必须引用证据。' },
      { 'role': 'user', 'content': prompt }
    ],
    'temperature': 0.2
  }
)
```

说明：温度设为 0.2 可以让回答更稳定。若老师问到“如果 API 失效怎么办”，可以说会设定重试机制与后备模型（例如本地部署版），并在监控面板透过 Prometheus + Grafana 跟踪请求成功率。一旦失败率升高，会自动切换到备援模式。
